Tema 2 - IOCLA - Digori Parascovia - 323CC

Scopul temei este mplementarea unor serii de criptari pentru a il ajuta pe Gigel sa pastreze formula leacului din timpurile unei ciume bubonice. Bine ca Gigel a salvat un editor de text si un asamblor 
nasm pentru arhitectura Intel x86 ca de altfel trebuia sa sculpeteze in piatra, saracul Gigel.

OTP Cipher - nu prea am ce comenta la problema asta, am stat totusi foarte mult ca sa ma prind cum functioneaza registrele. Intr-un loop parcurg octet cu octet plaintext-ul si cheia, fac xor pe 
octetii curenti din amebele siruri si pastrez rezultatul in edx-ciphertext.

Caesar Cipher - Parcurg in label-ul general_case octet cu octet pe esi, verific daca acest caracter este o litera mica sau o litera capital, daca da sar la label-urile convert_lowercase si convert_capital, care au acelasi principiu de functionare. Mai intaii aici adaugam caracterul curent cu cheia, scadem 'a', sau 'A', dupa caz, efectuam operatia de aritmetica modulara prin impartirea caracterului ca suma+cheie la 26, pentru a afla caracterul cifrat din alfabet (rest+'a') sau (rest+'A'). In cazul in care carcaterul din esi nu este o litera atunci el se adauga in ciphertext edx asa cum e si se trece la urmatorul octet din esi.

Vinegere Cipher - pastrez intr-o variabila lungimea la key, parcurg ca si la caesar plaintext-ul octet cu octet si verific daca este o litera lowercase sau capital, daca nu caracterul se adauga asa cum e in ciphertext. Daca este litera vom aduna octetul curent din cheie la octetul curent din plaintext, daca acest caracter depasestelimita maxima 'Z' sau 'z', atunci sar la compute_letter unde voi scadea 26 din caracter si acesta va fi caracterul cifrat. Prin increment_key trec la urmatorul octet din cheie si apoi in finalize_while trec la urmatorul octet din plaintext. In cazul in care ajungem la lungimea cheii sarim la fill_in_the_key pentru a restaura cheia pana la primul caracter. 

My_strstr - salvez intr-o variabila lungimea lui haystack_len pentru il elibera pe ecx, il parcurg pe plaintext octet cu octet si compar caracterul curent din esi cu prima litera din susbtring, daca se gaseste match atunci intru in check_substring. Aici decrementez lungimea substring-ului si verific daca am ajuns la 0, inseamna ca substring-ul a fost gasit in totalitate in haystack. Daca nu, atunci incrementam plaintextul si substringul  pentru a verifica match-ul dintre urmatoarele caractere, daca ele nu sunt egale pana se termina substringul atunci restabilim substringul si lungimea sa, apoi mergem la urmatorul caracter din esi. Daca am gasit substringul in haystack atunci pentru a ii afla pozitia de inceput o sa scad din pozitia curenta lungimea substringului si voi adauga 1, iar daca nu am gasit subtringul o sa retunez haystack_len + 1. 

bin_to_hex - mai intaii gasim lungimea sirului de output in hex prin impartirea lungimii sirului binar la 4, se va incrementa cu 1 catul (lungimea de output) daca exista rest. Inseram la pozitia len_output in ebx caracterul 10. Acum verificam de la finalul inputului fiecare caracter in grupuri de 4, pentru asta mentin un index care va aveam 
mereu valori intre 1 si 4 ceea ce ar reprezenta si pozitia caracterului in grupare, daca index este 1 inseamna ca caracterul daca are valoarea '1' va aduna intr-o suma ebx valoarea 1, daca index este 2 si '1' atunci aduna 2, daca index=2 si e '1' se aduna 4 si daca index=4 si '1' se aduna 8. In cazul in care nu caracterul nu este '1' se trece 
la urmatorul index si caracter din grupare. Daca avem o grupare intreaga cu index 4 atunci putem forma un caracter hex, pentru asta verific daca suma din ebx este < 10 -> make digit, in caz contrar se va face o litera. Dupa ce s-a aflat caracterul in hex il adaugam in resultat edx de la final spre inceput. 